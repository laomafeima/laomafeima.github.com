# PHP 常用设计模式
{2017-01-19}

在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。  
设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。
并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。
## 设计模式分类
《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式。
### 创建型模式
创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

- 简单工厂模式（Simple Factory）
- 工厂方法模式（Factory Method）
- 抽象工厂模式（Abstract Factory）
- 建造者模式（生成器模式）（Builder）
- 原型模式（Prototype）
- 单例模式（Singleton）

### 结构型模式
结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式。

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)门面模式
- 享元模式(Flyweight)
- 代理模式(Proxy)

### 行为型模式
行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。

行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

- 职责链模式(Chain of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)

## 设计模式
### 简单工厂模式
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
#### 参与者
- Factory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
- Product：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- ConcreteProduct：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例
#### 优点
- 使用者和创建者解耦合
- 无需知道类名，只需要知道参数即可获取对象
- 引入外部配置文件，可以在不修改代码的情况下更换产品角色
#### 缺点
- 扩展困难，需要修改和维护代码，可能会增加代码复杂度
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构
#### 适用场景
- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数
#### 类图
#### 时序图
#### 实例

	<?php
	
	abstract class ProductClass
	{
	    abstract public function productUse();
	}
	
	class ProductA extends ProductClass
	{
	    public function productUse()
	    {
	
	    }
	}
	
	class ProductB extends ProductClass
	{
	    public function productUse()
	    {
	
	    }
	}
	
	class Factory 
	{
	    static public function createProduct($p)
	    {
	        if ($p == "A")
	        {
	            return new ProductA();
	        }
	        else if($p == "B")
	        {
	            return new ProductB();
	        }
	        return null;
	    }
	}
	
	var_dump(Factory::createProduct("A"));

### 工厂模式
工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
#### 参与者
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
#### 优点
- 隐藏创建产品实例的细节
- 可以基于继承实现多态
- 加入新产品时，无需修改原有代码
#### 缺点
- 因为每个产品都需要实现一个对应的工厂类，会增加项目中类的个数，增加复杂度
#### 适用场景
- 利用对象的多态性，使得系统更容易扩展
- 不需要知道具体的产品类，使用者只需要知道工厂类即可。
#### 类图
#### 时序图
#### 实例

    <?php
    
    abstract class ProductClass
    {
        abstract public function productUse();
    }
    
    class ProductA extends ProductClass
    {
        public function productUse()
        {
    
        }
    }
    
    class ProductB extends ProductClass
    {
        public function productUse()
        {
    
        }
    }
    
    abstract class FactoryClass
    {
        abstract public function createProduct();
    }
    
    
    class FactoryA
    {
        public function createProduct()
        {
            return new ProductA();
        }
    }
    
    class FactoryB
    {
        public function createProduct()
        {
            return new ProductB();
        }
    }

### 抽象工厂模式
抽象工厂模式和工厂模式很像，只不过抽象工厂模式不仅仅提供一个产品，是提供一组有关系的产品。
#### 参与者
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
#### 优点
- 隐藏创建产品实例的细节
- 可以将一系列的产品对象设计在一个工厂里
- 加入新工厂和产品时，无需修改原有代码
#### 缺点
- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
- 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）
#### 适用场景
在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。
#### 类图
#### 时序图
#### 实例

    <?php
    
    abstract class ProductClass
    {
    }
    
    class ProductA1 extends ProductClass
    {
    }

    class ProductA2 extends ProductClass
    {
    }

    
    class ProductB1 extends ProductClass
    {
    }

    class ProductB2 extends ProductClass
    {
    }

    
    abstract class FactoryClass
    {
        abstract public function createProduct1();
        abstract public function createProduct2();
    }
    
    
    class FactoryA
    {
        public function createProduct1()
        {
            return new ProductA1();
        }

        public function createProduct2()
        {
            return new ProductA2();
        }

    }
    
    class FactoryB
    {
        public function createProduct1()
        {
            return new ProductB1();
        }
        public function createProduct2()
        {
            return new ProductB2();
        }

    }


### 建造者模式
建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。
#### 参与者
- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

#### 优点
- 建造者模式可以很好的将一个对象的实现与相关的“业务”逻辑分离开来，从而可以在不改变事件逻辑的前提下，使增加(或改变)实现变得非常容易。

#### 缺点
- 建造者接口的修改会导致所有执行类的修改。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

#### 适用场景
当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

#### 类图
#### 时序图
#### 实例

    <?php
    
    class Product 
    {
        private $_parts; 
        public function __construct() 
        {
            $this->_parts = array();
        }
        
        public function add($part) 
        {
            return array_push($this->_parts, $part);
        }
    }
     
    abstract class Builder
    {
        public abstract function buildPart1();
        public abstract function buildPart2();
        public abstract function getResult();
    }
     
    class ConcreteBuilder extends Builder 
    {
        private $_product;
        public function __construct() 
        {
            $this->_product = new Product();
        }
        public function buildPart1() 
        {
            $this->_product->add("Part1");
        } 
        public function buildPart2()
        {
            $this->_product->add("Part2");
        }
        public function getResult() 
        {
            return $this->_product;
        }
    }
    
    class Director 
    { 
        public function __construct(Builder $builder) 
        {
            $builder->buildPart1();
            $builder->buildPart2();
        }
    }
    
    // client 
    $buidler = new ConcreteBuilder();
    $director = new Director($buidler);
    $product = $buidler->getResult();

### 单例模式
单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。
#### 参与者
- Singleton：单例

#### 优点
- 提供了对唯一实例的受控访问

#### 缺点
- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。

#### 适用场景
系统只需要一个实例对象

#### 类图
#### 时序图
#### 实例

    <?php
    
    class Product 
    {
        static private $_object;
        private function __construct() 
        {
        }
        public function __clone()
        {
            die();
        }
        static public function getInstance() 
        {
            if(!self::$_object)
            {
                self::$_object = new Product();
            }
            return self::$_object;
        }
    }
