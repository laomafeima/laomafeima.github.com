# PHP 常用设计模式
{2017-01-19}

在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。  
设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。
并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。
## 设计模式分类
《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式。
### 创建型模式
创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

- 简单工厂模式（Simple Factory）
- 工厂方法模式（Factory Method）
- 抽象工厂模式（Abstract Factory）
- 建造者模式（生成器模式）（Builder）
- 原型模式（Prototype）
- 单例模式（Singleton）

### 结构型模式
结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式。

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)门面模式
- 享元模式(Flyweight)
- 代理模式(Proxy)

### 行为型模式
行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。

行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

- 职责链模式(Chain of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)

## 设计模式
### 简单工厂模式
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
#### 参与者
- Factory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
- Product：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- ConcreteProduct：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例
#### 优点
- 使用者和创建者解耦合
- 无需知道类名，只需要知道参数即可获取对象
- 引入外部配置文件，可以在不修改代码的情况下更换产品角色
#### 缺点
- 扩展困难，需要修改和维护代码，可能会增加代码复杂度
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构
#### 适用场景
- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数
#### 类图
#### 时序图
#### 实例

	<?php
	
	abstract class ProductClass
	{
	    abstract public function productUse();
	}
	
	class ProductA extends ProductClass
	{
	    public function productUse()
	    {
	
	    }
	}
	
	class ProductB extends ProductClass
	{
	    public function productUse()
	    {
	
	    }
	}
	
	class Factory 
	{
	    static public function createProduct($p)
	    {
	        if ($p == "A")
	        {
	            return new ProductA();
	        }
	        else if($p == "B")
	        {
	            return new ProductB();
	        }
	        return null;
	    }
	}
	
	var_dump(Factory::createProduct("A"));

### 工厂模式
工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
#### 参与者
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
#### 优点
- 隐藏创建产品实例的细节
- 可以基于继承实现多态
- 加入新产品时，无需修改原有代码
#### 缺点
- 因为每个产品都需要实现一个对应的工厂类，会增加项目中类的个数，增加复杂度
#### 适用场景
- 利用对象的多态性，使得系统更容易扩展
- 不需要知道具体的产品类，使用者只需要知道工厂类即可。
#### 类图
#### 时序图
#### 实例

    <?php
    
    abstract class ProductClass
    {
        abstract public function productUse();
    }
    
    class ProductA extends ProductClass
    {
        public function productUse()
        {
    
        }
    }
    
    class ProductB extends ProductClass
    {
        public function productUse()
        {
    
        }
    }
    
    abstract class FactoryClass
    {
        abstract public function createProduct();
    }
    
    
    class FactoryA
    {
        public function createProduct()
        {
            return new ProductA();
        }
    }
    
    class FactoryB
    {
        public function createProduct()
        {
            return new ProductB();
        }
    }

### 抽象工厂模式
抽象工厂模式和工厂模式很像，只不过抽象工厂模式不仅仅提供一个产品，是提供一组有关系的产品。
#### 参与者
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
#### 优点
- 隐藏创建产品实例的细节
- 可以将一系列的产品对象设计在一个工厂里
- 加入新工厂和产品时，无需修改原有代码
#### 缺点
- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
- 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）
#### 适用场景
在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。
#### 类图
#### 时序图
#### 实例

    <?php
    
    abstract class ProductClass
    {
    }
    
    class ProductA1 extends ProductClass
    {
    }

    class ProductA2 extends ProductClass
    {
    }

    
    class ProductB1 extends ProductClass
    {
    }

    class ProductB2 extends ProductClass
    {
    }

    
    abstract class FactoryClass
    {
        abstract public function createProduct1();
        abstract public function createProduct2();
    }
    
    
    class FactoryA
    {
        public function createProduct1()
        {
            return new ProductA1();
        }

        public function createProduct2()
        {
            return new ProductA2();
        }

    }
    
    class FactoryB
    {
        public function createProduct1()
        {
            return new ProductB1();
        }
        public function createProduct2()
        {
            return new ProductB2();
        }

    }


### 建造者模式
建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。
#### 参与者
- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品角色

#### 优点
- 建造者模式可以很好的将一个对象的实现与相关的“业务”逻辑分离开来，从而可以在不改变事件逻辑的前提下，使增加(或改变)实现变得非常容易。

#### 缺点
- 建造者接口的修改会导致所有执行类的修改。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

#### 适用场景
当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

#### 类图
#### 时序图
#### 实例

    <?php
    
    class Product 
    {
        private $_parts; 
        public function __construct() 
        {
            $this->_parts = array();
        }
        
        public function add($part) 
        {
            return array_push($this->_parts, $part);
        }
    }
     
    abstract class Builder
    {
        public abstract function buildPart1();
        public abstract function buildPart2();
        public abstract function getResult();
    }
     
    class ConcreteBuilder extends Builder 
    {
        private $_product;
        public function __construct() 
        {
            $this->_product = new Product();
        }
        public function buildPart1() 
        {
            $this->_product->add("Part1");
        } 
        public function buildPart2()
        {
            $this->_product->add("Part2");
        }
        public function getResult() 
        {
            return $this->_product;
        }
    }
    
    class Director 
    { 
        public function __construct(Builder $builder) 
        {
            $builder->buildPart1();
            $builder->buildPart2();
        }
    }
    
    // client 
    $buidler = new ConcreteBuilder();
    $director = new Director($buidler);
    $product = $buidler->getResult();

### 单例模式
单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。
#### 参与者
- Singleton：单例

#### 优点
- 提供了对唯一实例的受控访问

#### 缺点
- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起

#### 适用场景
系统只需要一个实例对象

#### 类图
#### 时序图
#### 实例

    <?php
    
    class Product 
    {
        static private $_object;
        private function __construct() 
        {
        }
        public function __clone()
        {
            die();
        }
        static public function getInstance() 
        {
            if(!self::$_object)
            {
                self::$_object = new Product();
            }
            return self::$_object;
        }
    }

### 适配器模式
适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

#### 参与者
- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类

#### 优点
- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码
- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性
- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”

#### 缺点
- 类适配器模式的缺点如下：
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口
- 对象适配器模式的缺点如下：
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂

#### 适用场景
- 你想使用一个已经存在的类，而它的接口不符合你的需求
- 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
- 你想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口（仅限于对象适配器）

#### 类图
#### 时序图
#### 实例

    <?php
    
    interface Target {
        public function sampleMethod1();
        public function sampleMethod2();
    }
     
    class Adaptee {
        public function sampleMethod1() {}
    }
     
    class Adapter implements Target {
        private $_adaptee;
        public function __construct(Adaptee $adaptee) {
            $this->_adaptee = $adaptee;
        }
     
        public function sampleMethod1() { $this->_adaptee->sampleMethod1(); }
     
        public function sampleMethod2() {}
    }
     
    $adaptee = new Adaptee();
    $adapter = new Adapter($adaptee);
    $adapter->sampleMethod1();
    $adapter->sampleMethod2();

### 外观模式
外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

#### 参与者
- Facade: 外观角色
- SubSystem:子系统角色

#### 优点
- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可
- 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类

#### 缺点
- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”

#### 适用场景
- 当要为一个复杂子系统提供一个简单接口时可以使用外观模式
- 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性
- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度

#### 类图
#### 时序图
#### 实例

    <?php
    
    class Camera 
    {
        public function turnOn() {}
            public function turnOff() {}
            public function rotate($degrees) {}
    }
    
    class Light 
    {
        public function turnOn() {}
            public function turnOff() {}
            public function changeBulb() {}
    }
    
    class Sensor 
    {
        public function activate() {}
            public function deactivate() {}
            public function trigger() {}
    }
    
    class Alarm 
    {
        public function activate() {}
            public function deactivate() {}
            public function ring() {}
            public function stopRing() {}
    }
    
    class SecurityFacade 
    {
        private $_camera1, $_camera2;
        private $_light1, $_light2, $_light3;
        private $_sensor;
        private $_alarm;
    
        public function __construct() 
        {
            $this->_camera1 = new Camera();
            $this->_camera2 = new Camera();
    
            $this->_light1 = new Light();
            $this->_light2 = new Light();
            $this->_light3 = new Light();
    
            $this->_sensor = new Sensor();
            $this->_alarm = new Alarm();
        }
    
        public function activate() 
        {
            $this->_camera1->turnOn();
            $this->_camera2->turnOn();
    
            $this->_light1->turnOn();
            $this->_light2->turnOn();
            $this->_light3->turnOn();
    
            $this->_sensor->activate();
            $this->_alarm->activate();
        }
    
        public  function deactivate() 
        {
            $this->_camera1->turnOff();
            $this->_camera2->turnOff();
    
            $this->_light1->turnOff();
            $this->_light2->turnOff();
            $this->_light3->turnOff();
    
            $this->_sensor->deactivate();
            $this->_alarm->deactivate();
        }
    }
    
    
    //client 
    $security = new SecurityFacade();
    $security->activate();

### 命令模式
命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

#### 参与者
- Command: 抽象命令类
- ConcreteCommand: 具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client: 客户端

#### 优点
- 降低系统的耦合度
- 新的命令可以很容易地加入到系统中
- 可以比较容易地设计一个命令队列和宏命令（组合命令）
- 可以方便地实现对请求的Undo和Redo

#### 缺点
- 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用

#### 适用场景
- 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互
- 系统需要在不同的时间指定请求、将请求排队和执行请求
- 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作
- 系统需要将一组操作组合在一起，即支持宏命令

#### 类图
#### 时序图
#### 实例

    <?php
    
    interface Command 
    {
        public function execute(); // 执行方法
    }
    
    class ConcreteCommand implements Command 
    { 
        private $_receiver; 
        public function __construct(Receiver $receiver) 
        {
            $this->_receiver = $receiver;
        }
        public function execute() 
        {
            $this->_receiver->action();
        }
    }
    
    class Receiver 
    {
        private $_name;
        public function __construct($name) 
        {
            $this->_name = $name;
        }
        public function action() { }
    }
    
    class Invoker 
    {
        private $_command; 
        public function __construct(Command $command) 
        {
            $this->_command = $command;
        }
        public function action() 
        {
            $this->_command->execute();
        }
    }
    
    $receiver = new Receiver('hello world');
    $command = new ConcreteCommand($receiver);
    $invoker = new Invoker($command);
    $invoker->action();

### 观察者模式
观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

#### 参与者
- Subject: 目标
- ConcreteSubject: 具体目标
- Observer: 观察者
- ConcreteObserver: 具体观察者

#### 优点
- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合
- 观察者模式支持广播通信
- 观察者模式符合“开闭原则”的要求

#### 缺点
- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化

#### 适用场景
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度
- 一个对象必须通知其他对象，而并不知道这些对象是谁
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制


#### 类图
#### 时序图
#### 实例

    <?php
    
    interface Subject 
    {
        public function attach(Observer $observer); // 增加一个新的观察者对象
        public function detach(Observer $observer); // 删除一个已注册过的观察者对象
        public function notifyObservers(); // 通知所有注册过的观察者对象
    }
    
    class ConcreteSubject implements Subject 
    { // 具体主题角色
        private $_observers; 
        public function __construct() 
        { 
            $this->_observers = array(); 
        }
        public function attach(Observer $observer) 
        {
            return array_push($this->_observers, $observer);
        }
        public function detach(Observer $observer) 
        {
            $index = array_search($observer, $this->_observers);
            if ($index === false || ! array_key_exists($index, $this->_observers)) 
            {
                return false;
            } 
            unset($this->_observers[$index]);
            return true;
        }
        public function notifyObservers() 
        {
            if (!is_array($this->_observers)) 
            { 
                return false; 
        } 
        foreach ($this->_observers as $observer) 
        { 
            $observer->update(); 
        } 
            return true;
        }
    
    }
    
    interface Observer 
    { // 抽象观察者角色
        public function update(); // 更新方法
    }
    
    class ConcreteObserver implements Observer 
    {
        private $_name; 
        public function __construct($name) 
        { 
            $this->_name = $name; 
        }
        public function update() 
        {
        }
    }
    
    $subject = new ConcreteSubject();
    
    /* 添加第一个观察者 */
    $observer1 = new ConcreteObserver('Mac');
    $subject->attach($observer1);
    $subject->notifyObservers(); // 主题变化，通知观察者
    
    /* 添加第二个观察者 */
    $observer2 = new ConcreteObserver('Win');
    $subject->attach($observer2);
    $subject->notifyObservers();
    
    $subject->detach($observer1);
    $subject->notifyObservers();

### 迭代器模式
迭代器模式是一种行为型模式，它是一种最简单也最常见的设计模式。它可以让使用者透过特定的接口巡访容器中的每一个元素而不用了解底层的实作。

#### 适用场景
在希望利用语言本身的遍历函数便利自定义结构时，例如PHP中的foreach函数

#### 类图
#### 时序图
#### 实例

    <?php
    
    class sample implements Iterator 
    {
        private $_items ;
    
        public function __construct(&$data) 
        {
            $this->_items = $data;
        }
        public function current() 
        {
            return current($this->_items);
        }
    
        public function next() 
        {
            next($this->_items);   
        }
    
        public function key() 
        {
            return key($this->_items);
        }
    
        public function rewind() 
        {
            reset($this->_items);
        }
    
        public function valid() 
        { 
            return ($this->current() !== false);
        }
    }

### 策略模式
策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。

#### 参与者
- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类

#### 优点
- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为
- 策略模式提供了管理相关的算法族的办法
- 策略模式提供了可以替换继承关系的办法
- 使用策略模式可以避免使用多重条件转移语句

#### 缺点
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类
- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量

#### 适用场景
- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为
- 一个系统需要动态地在几种算法中选择一种
- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现
- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性

#### 类图
#### 时序图
#### 实例

    <?php
    
    interface State 
    { // 抽象状态角色
        public function handle(Context $context); // 方法示例
    }
    
    class ConcreteStateA implements State 
    { // 具体状态角色A
        private static $_instance = null;
        private function __construct() {}
        public static function getInstance() 
        { // 静态工厂方法，返还此类的唯一实例
            if (is_null(self::$_instance)) 
            {
                self::$_instance = new ConcreteStateA();
            }
            return self::$_instance;
        }
    
        public function handle(Context $context) 
        {
            $context->setState(ConcreteStateB::getInstance());
        }
    
    }
    
    class ConcreteStateB implements State 
    { // 具体状态角色B
        private static $_instance = null;
        private function __construct() 
        {
    }
    public static function getInstance() 
    {
        if (is_null(self::$_instance)) 
        {
            self::$_instance = new ConcreteStateB();
            }
            return self::$_instance;
        }
    
        public function handle(Context $context) 
        {
            $context->setState(ConcreteStateA::getInstance());
        }
    }
    
    class Context 
    { // 环境角色 
        private $_state;
        public function __construct() 
        { // 默认为stateA
            $this->_state = ConcreteStateA::getInstance();
        }
        public function setState(State $state) 
        {
            $this->_state = $state;
        }
        public function request() 
        {
            $this->_state->handle($this);
        }
    }
    
    // client
    $context = new Context();
    $context->request();

### 享元模式
享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

#### 参与者
- Flyweight: 抽象享元类
- ConcreteFlyweight: 具体享元类
- UnsharedConcreteFlyweight: 非共享具体享元类
- FlyweightFactory: 享元工厂类

#### 优点
- 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享

#### 缺点
- 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化
- 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长

#### 适用场景
- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式

#### 类图
#### 时序图
#### 实例

    <?php
    
    abstract class Flyweight 
    { // 抽象享元角色
        abstract public function operation($state);
    }
    
    class ConcreteFlyweight extends Flyweight 
    { // 具体享元角色
        private $_intrinsicState = null; 
        public function __construct($state) 
        {
            $this->_intrinsicState = $state;
        }
        public function operation($state) 
        {
        }
    }
    
    class UnsharedConcreteFlyweight extends Flyweight 
    { // 不共享的具体享元，客户端直接调用
        private $_intrinsicState = null;
        public function __construct($state) 
        {
            $this->_intrinsicState = $state;
        }
        public function operation($state) 
        {
        }
    }
    
    class FlyweightFactory 
    { // 享元工厂角色 
        private $_flyweights;
        public function __construct() 
        {
            $this->_flyweights = array();
        }
        public function getFlyweigth($state) 
        {
            if (isset($this->_flyweights[$state])) 
            {
                return $this->_flyweights[$state];
            } 
            else 
            {
                return $this->_flyweights[$state] = new ConcreteFlyweight($state);
            }
        }
    }
    
    // client
    $flyweightFactory = new FlyweightFactory();
    $flyweight = $flyweightFactory->getFlyweigth('state A');
    $flyweight->operation('other state A');
    
    $flyweight = $flyweightFactory->getFlyweigth('state B');
    $flyweight->operation('other state B');
    
    // 不共享的对象，单独调用
    $uflyweight = new UnsharedConcreteFlyweight('state A');
    $uflyweight->operation('other state A');


*以上内容引用自[图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html)，[设计模式详解](http://yansu.org/2014/04/19/design-patterns-of-php.html)*