<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="markdown-hash" content="">

    <title>GDB 手册</title>

    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
<header>
    <div id="go-back" onclick="javascript:history.back(-1);">↼</div>
</header>
<div class="markdown-body">
    <h1>GDB</h1>
<h2>1. gdb 调试利器</h2>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p>
<h3>1.1. 启动gdb</h3>
<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<pre><code>$g++ -g hello.cpp -o hello
</code></pre>

<p>调试可执行文件:</p>
<pre><code>$gdb &lt;program&gt;
</code></pre>

<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<pre><code>$gdb &lt;program&gt; &lt;core dump file&gt;
$gdb program core.11127
</code></pre>

<p>调试服务程序:</p>
<pre><code>$gdb &lt;program&gt; &lt;PID&gt;
$gdb hello 11127
</code></pre>

<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h3>1.2. gdb交互命令</h3>
<p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h4>运行</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>run</td>
<td>简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</td>
</tr>
<tr>
<td>continue</td>
<td>（简写c ）：继续执行，到下一个断点处（或运行结束）。</td>
</tr>
<tr>
<td>next</td>
<td>（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</td>
</tr>
<tr>
<td>step</td>
<td>（简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的。</td>
</tr>
<tr>
<td>until</td>
<td>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</td>
</tr>
<tr>
<td>until+行号</td>
<td>运行至某行，不仅仅用来跳出循环。</td>
</tr>
<tr>
<td>finish</td>
<td>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</td>
</tr>
<tr>
<td>call 函数(参数)</td>
<td>调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</td>
</tr>
<tr>
<td>quit</td>
<td>简记为 q ，退出 gdb。</td>
</tr>
</tbody>
</table>
<h4>设置断点</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>break n （简写b n）</td>
<td>在第n行处设置断点。（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</td>
</tr>
<tr>
<td>b fn1 if a＞b</td>
<td>条件断点设置。</td>
</tr>
<tr>
<td>break func（break缩写为b）</td>
<td>在函数func()的入口处设置断点，如：break cb_button。</td>
</tr>
<tr>
<td>delete 断点号n</td>
<td>删除第n个断点。</td>
</tr>
<tr>
<td>disable 断点号n</td>
<td>暂停第n个断点。</td>
</tr>
<tr>
<td>enable 断点号n</td>
<td>开启第n个断点。</td>
</tr>
<tr>
<td>clear 行号n</td>
<td>清除第n行的断点。</td>
</tr>
<tr>
<td>info b （info breakpoints）</td>
<td>显示当前程序的断点设置情况。</td>
</tr>
<tr>
<td>delete breakpoints</td>
<td>清除所有断点。</td>
</tr>
</tbody>
</table>
<h4>查看源代码</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</td>
</tr>
<tr>
<td>list 行号</td>
<td>将显示当前文件以“行号”为中心的前后10行代码，如：list 12</td>
</tr>
<tr>
<td>list 函数名</td>
<td>将显示“函数名”所在函数的源代码，如：list main</td>
</tr>
<tr>
<td>list</td>
<td>不带参数，将接着上一次 list 命令的，输出下边的内容。</td>
</tr>
</tbody>
</table>
<h4>打印表达式</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>print 表达式</td>
<td>简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</td>
</tr>
<tr>
<td>print a</td>
<td>将显示整数 a 的值。</td>
</tr>
<tr>
<td>print ++a</td>
<td>将把 a 中的值加1,并显示出来。</td>
</tr>
<tr>
<td>print name</td>
<td>将显示字符串 name 的值。</td>
</tr>
<tr>
<td>print gdb_test(22)</td>
<td>将以整数22作为参数调用 gdb_test() 函数。</td>
</tr>
<tr>
<td>print gdb_test(a)</td>
<td>将以变量 a 作为参数调用 gdb_test() 函数。</td>
</tr>
<tr>
<td>display 表达式</td>
<td>在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a。</td>
</tr>
<tr>
<td>watch 表达式</td>
<td>设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a。</td>
</tr>
<tr>
<td>whatis</td>
<td>查询变量或函数。</td>
</tr>
<tr>
<td>info function</td>
<td>查询函数。</td>
</tr>
<tr>
<td>info locals</td>
<td>显示当前堆栈页的所有变量。</td>
</tr>
</tbody>
</table>
<h4>查询运行信息</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>where/bt</td>
<td>当前运行的堆栈列表。</td>
</tr>
<tr>
<td>bt backtrace</td>
<td>显示当前调用堆栈。</td>
</tr>
<tr>
<td>up/down</td>
<td>改变堆栈显示的深度。</td>
</tr>
<tr>
<td>set args</td>
<td>参数:指定运行时的参数。</td>
</tr>
<tr>
<td>show args</td>
<td>查看设置好的参数。</td>
</tr>
<tr>
<td>info program</td>
<td>来查看程序的是否在运行，进程号，被暂停的原因。</td>
</tr>
</tbody>
</table>
<h4>分割窗口</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>layout</td>
<td>用于分割窗口，可以一边查看代码，一边测试。</td>
</tr>
<tr>
<td>layout src</td>
<td>显示源代码窗口。</td>
</tr>
<tr>
<td>layout asm</td>
<td>显示反汇编窗口。</td>
</tr>
<tr>
<td>layout regs</td>
<td>显示源代码/反汇编和CPU寄存器窗口。</td>
</tr>
<tr>
<td>layout split</td>
<td>显示源代码和反汇编窗口。</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>刷新窗口。</td>
</tr>
</tbody>
</table>
<h4>注解</h4>
<blockquote>
<p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便。</p>
</blockquote>
<p><em>内容复制自<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb 调试利器</a></em></p>
</div>
<div class="bottom">
    
    <a href="/tag/Vim.html" class="tag" ># Vim</a>
    
    <time datetime="2019-07-21">2019-07-21</time>
</div>
<footer>
    <a href="/notes.html" target="_blank" class="muted"><i>笔记</i></a>
    <i>/</i>
    <a href="/tags.html" target="_blank" class="muted"><i>标签</i></a>
    <i>/</i>
    <a href="/about.html" target="_blank" class="muted"><i>关于</i></a>
</footer>
<script src="/static/min.js"></script>
</body>
</html>